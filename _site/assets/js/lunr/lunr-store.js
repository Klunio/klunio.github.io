var store = [{
        "title": "Django Note",
        "excerpt":"1.安装   Django需要数据库，所以先安装mysql或者oracle，然后pip install Django就好   验证安装可以可以在python shell 中输入   import django print(django.get_version()) &gt;&gt;&gt; 2.1   2.文件结构   运行命令django-admin startproject mysite，可以创建一个django项目   mysite/     manage.py     mysite/         __init__.py         settings.py         urls.py         wsgi.py      manage.py是一个让你用各种方式管理Django项目的命令行工具，更多阅读django-admin and manage.py   mysite/ 包含你的所有项目文件   mysite/settings 是Django的配置文件，更多阅读Django settings   mysite/urls.py是Django的URL声明，类似网站的目录   mysite/wsgi.py是项目运行哎WSGI兼容的Web服务器上的入口   3. 配置数据库   打开mysite/settings.py，这是个包含了 Django 项目设置的 Python 模块。   通常，这个配置文件使用 SQLite 作为默认数据库。如果你不熟悉数据库，或者只是想尝试下 Django，这是最简单的选择。Python 内置 SQLite，所以你无需安装额外东西来使用它。当你开始一个真正的项目时，你可能更倾向使用一个更具扩展性的数据库，例如 PostgreSQL，避免中途切换数据库这个令人头疼的问题。   如果你想使用其他数据库，你需要安装合适的 database bindings ，然后改变设置文件中 DATABASES 'default' 项目中的一些键值：      ENGINE – 可选值有 'django.db.backends.sqlite3'，'django.db.backends.postgresql'，'django.db.backends.mysql'，或 'django.db.backends.oracle'。其它 可用后端。   NAME - 数据库的名称。如果使用的是 SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。默认值 os.path.join(BASE_DIR, 'db.sqlite3') 将会把数据库文件储存在项目的根目录。   如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。想了解更多数据库设置方面的内容，请看文档：DATABASES 。   编辑 mysite/settings.py 文件前，先设置 TIME_ZONE 为你自己时区。   此外，关注一下文件头部的 INSTALLED_APPS 设置项。这里包括了会在你项目中启用的所有 Django 应用。应用能在多个项目中使用，你也可以打包并且发布应用，让别人使用它们。   通常， INSTALLED_APPS 默认包括了以下 Django 的自带应用：      django.contrib.admin – 管理员站点， 你很快就会使用它。   django.contrib.auth – 认证授权系统。   django.contrib.contenttypes – 内容类型框架。   django.contrib.sessions – 会话框架。   django.contrib.messages – 消息框架。   django.contrib.staticfiles – 管理静态文件的框架。   这些应用被默认启用是为了给常规项目提供方便。   默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表。请执行以下命令：   $ python manage.py migrate   4. 创建模型   在model.py文件中编写我们需要的类，例如：   from django.db import models   class Question(models.Model):     question_text = models.CharField(max_length=200)     pub_date = models.DateTimeField('date published')   class Choice(models.Model):     question = models.ForeignKey(Question, on_delete=models.CASCADE)     choice_text = models.CharField(max_length=200)     votes = models.IntegerField(default=0)   这样我们就在数据库中生成了2张表，代码十分清晰，不多加解释   这样的代码给了django很多信息，通过这些信息django可以      为这个应用创建数据库shcema(生成 CREATE TABLE语句)   创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。      Django 应用是“可插拔”的。你可以在多个项目中使用同一个应用。除此之外，你还可以发布自己的应用，因为它们并不会被绑定到当前安装的 Django 上。    polls的配置信息在app.py这个文件中，所以我们将polls.apps.PollConfig这个信息写入 INSTALLED_APPS中，接着运行python manage.py makemigrations polls,我们就可以得到如下类似的输出：   Migrations for 'polls':   polls/migrations/0001_initial.py:     - Create model Choice     - Create model Question     - Add field question to choice   通过makemigrations命令，Django会检测你对模型文件的修改，并且把修改的部分储存作为一次 迁移。   迁移是 Django 对于模型定义（也就是你的数据库结构）的变化的储存形式 - 没那么玄乎，它们其实也只是一些你磁盘上的文件。如果你想的话，你可以阅读一下你模型的迁移数据，它被储存在 polls/migrations/0001_initial.py 里。别担心，你不需要每次都阅读迁移文件，但是它们被设计成人类可读的形式，这是为了便于你手动修改它们。   sqlmigrate 命令接收一个迁移的名称，然后返回对应的 SQL：   $ python manage.py sqlmigrate polls 0001   我们可以得到类似的输出   BEGIN; -- -- Create model Choice -- CREATE TABLE \"polls_choice\" (     \"id\" serial NOT NULL PRIMARY KEY,     \"choice_text\" varchar(200) NOT NULL,     \"votes\" integer NOT NULL ); -- -- Create model Question -- CREATE TABLE \"polls_question\" (     \"id\" serial NOT NULL PRIMARY KEY,     \"question_text\" varchar(200) NOT NULL,     \"pub_date\" timestamp with time zone NOT NULL ); -- -- Add field question to choice -- ALTER TABLE \"polls_choice\" ADD COLUMN \"question_id\" integer NOT NULL; ALTER TABLE \"polls_choice\" ALTER COLUMN \"question_id\" DROP DEFAULT; CREATE INDEX \"polls_choice_7aa0f6ee\" ON \"polls_choice\" (\"question_id\"); ALTER TABLE \"polls_choice\"   ADD CONSTRAINT \"polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id\"     FOREIGN KEY (\"question_id\")     REFERENCES \"polls_question\" (\"id\")     DEFERRABLE INITIALLY DEFERRED;  COMMIT;   再次运行 migrate 命令，在数据库里创建新定义的模型的数据表   这个 migrate 命令选中所有还没有执行过的迁移（Django 通过在数据库中创建一个特殊的表 django_migrations 来跟踪执行过哪些迁移）并应用在数据库上 - 也就是将你对模型的更改同步到数据库结构上。   迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表 - 它专注于使数据库平滑升级而不会丢失数据。我们会在后面的教程中更加深入的学习这部分内容，现在，你只需要记住，改变模型需要这三步：      编辑 models.py 文件，改变模型。   运行 python manage.py makemigrations 为模型的改变生成迁移文件。   运行 python manage.py migrate 来应用数据库迁移。   数据库迁移被分解成生成和应用两个命令是为了让你能够在代码控制系统上提交迁移数据并使其能在多个应用里使用；这不仅仅会让开发更加简单，也给别的开发者和生产环境中的使用带来方便。   5. 使用 Django Shell   python3 manage.py shell   6. 创建管理员账号   python manage.py createsuperuser   7. 路由   在配置项中 ROOT_URLCONF中设置根路由   例如 ROOT_URLCONF=mysite.urlsDjango将载入mysite.urls模块，然后寻找名为urlpatterns的变量并且按序匹配正则表达项。   8. 个人的一些总结   ​\t虽然之前毫无接触过Django（只是简单的使用过flask），而且公司的代码是用的Django rest framework，不过通过阅读代码和官方的教程，目前有以下的理解。   ​\t首先后台启动靠的就是一个setting文件，里面有各种关键的配置，比如ALLOWED_HOSTS、INSTALLED_APPS等等，其中ROOT_URLCONF定义了根路由节点，TEMPLATES定义了模板导入的方式，DATABASES定义了数据库的类型，其实还有好多可以配置啦。   ​\t然后就是路由，路由中的url匹配还蛮好理解的，include是一个蛮有趣的设定，满足的django即插即用又各个应用组成的理念。通过include可以截断前面匹配的url，然后将剩下的部分导入子路由，   ​\t匹配urlpattern之后就是views了，在views中定义各种类和函数，就可以在访问这个api的时候返回模板、html、httpresponse…模板是一个蛮强的东西，不过目前项目的代码没有用到，所以也没有太深入理解。   ​\t另一个比较重要的是模型的构建，Django可以直接生成要使用的数据库，并且使用migrate可以很便捷的进行修改和增删。创建数据库的步骤大概如下：      首先在model文件中定义我们需要的表   运行 python manage.py makemigrations 为模型的改变生成迁移文件   运行 python manage.py migrate 来应用数据库迁移   完成这3步之后会在migrations文件夹中生成模型定义，也是py文件而且蛮容易阅读的。  ","categories": ["note","Django"],
        "tags": [],
        "url": "http://localhost:4000/Django/Django-Note/",
        "teaser":null},{
        "title": "Model in Django",
        "excerpt":"   refer    Django中所有的模型都必须继承django.db.models.Model模型，不管是直接继承也好，还是间接继承也罢。   你唯一需要决定的是，父模型是否是一个独立自主的，同样在数据库中创建数据表的模型，还是一个只用来保存子模型共有内容，并不实际创建数据表的抽象模型。   Django有三种继承的方式：      抽象基类：被用来继承的模型被称为Abstract base classes，将子类共同的数据抽离出来，供子类继承重用，它不会创建实际的数据表；   多表继承：Multi-table inheritance，每一个模型都有自己的数据库表；   代理模型：如果你只想修改模型的Python层面的行为，并不想改动模型的字段，可以使用代理模型。   一、抽象基类   只需要在模型的Meta类里添加abstract=True元数据项，就可以将一个模型转换为抽象基类。Django不会为这种类创建实际的数据库表，它们也没有管理器，不能被实例化也无法直接保存，它们就是用来被继承的。抽象基类完全就是用来保存子模型们共有的内容部分，达到重用的目的。当它们被继承时，它们的字段会全部复制到子模型中。看下面的例子：   from django.db import models  class CommonInfo(models.Model):     name = models.CharField(max_length=100)     age = models.PositiveIntegerField()      class Meta:         abstract = True  class Student(CommonInfo):     home_group = models.CharField(max_length=5)   Student模型将拥有name，age，home_group三个字段，并且CommonInfo模型不能当做一个正常的模型使用。   抽象基类的Meta数据：   如果子类没有声明自己的Meta类，那么它将继承抽象基类的Meta类。下面的例子则扩展了基类的Meta：   from django.db import models  class CommonInfo(models.Model):     # ...     class Meta:         abstract = True         ordering = ['name']  class Student(CommonInfo):     # ...     class Meta(CommonInfo.Meta):         db_table = 'student_info'   这里有几点要特别说明：      抽象基类中有的元数据，子模型没有的话，直接继承；   抽象基类中有的元数据，子模型也有的话，直接覆盖；   子模型可以额外添加元数据；   抽象基类中的abstract=True这个元数据不会被继承。也就是说如果想让一个抽象基类的子模型，同样成为一个抽象基类，那你必须显式的在该子模型的Meta中同样声明一个abstract = True；   有一些元数据对抽象基类无效，比如db_table，首先是抽象基类本身不会创建数据表，其次它的所有子类也不会按照这个元数据来设置表名。   警惕related_name和related_query_name参数   如果在你的抽象基类中存在ForeignKey或者ManyToManyField字段，并且使用了related_name或者related_query_name参数，那么一定要小心了。因为按照默认规则，每一个子类都将拥有同样的字段，这显然会导致错误。为了解决这个问题，当你在抽象基类中使用related_name或者related_query_name参数时，它们两者的值中应该包含%(app_label)s和%(class)s部分：      %(class)s用字段所属子类的小写名替换   %(app_label)s用子类所属app的小写名替换   例如，对于common/models.py模块：   from django.db import models  class Base(models.Model):     m2m = models.ManyToManyField(     OtherModel,     related_name=\"%(app_label)s_%(class)s_related\",     related_query_name=\"%(app_label)s_%(class)ss\",     )      class Meta:         abstract = True  class ChildA(Base):     pass  class ChildB(Base):     pass   对于另外一个应用中的rare/models.py:   from common.models import Base  class ChildB(Base):     pass   对于上面的继承关系：      common.ChildA.m2m字段的reverse name（反向关系名）应该是common_childa_related；reverse query name(反向查询名)应该是common_childas。   common.ChildB.m2m字段的反向关系名应该是common_childb_related；反向查询名应该是common_childbs。   rare.ChildB.m2m字段的反向关系名应该是rare_childb_related；反向查询名应该是rare_childbs。   当然，如果你不设置related_name或者related_query_name参数，这些问题就不存在了。   二、多表继承   这种继承方式下，父类和子类都是独立自主、功能完整、可正常使用的模型，都有自己的数据库表，内部隐含了一个一对一的关系。例如：   from django.db import models  class Place(models.Model):     name = models.CharField(max_length=50)     address = models.CharField(max_length=80)  class Restaurant(Place):     serves_hot_dogs = models.BooleanField(default=False)     serves_pizza = models.BooleanField(default=False)   Restaurant将包含Place的所有字段，并且各有各的数据库表和字段，比如：   &gt;&gt;&gt; Place.objects.filter(name=\"Bob's Cafe\") &gt;&gt;&gt; Restaurant.objects.filter(name=\"Bob's Cafe\")   如果一个Place对象同时也是一个Restaurant对象，你可以使用小写的子类名，在父类中访问它，例如：   &gt;&gt;&gt; p = Place.objects.get(id=12) # 如果p也是一个Restaurant对象，那么下面的调用可以获得该Restaurant对象。 &gt;&gt;&gt; p.restaurant &lt;Restaurant: ...&gt;   其机制内部隐含的OneToOne字段，形同下面所示：   place_ptr = models.OneToOneField(     Place, on_delete=models.CASCADE,     parent_link=True, )   可以通过创建一个OneToOneField字段并设置 parent_link=True，自定义这个一对一字段。   #####个人理解：   假设B继承于A：      A和B的表是独立的   因为B继承于A，因此在创建B的时候也会同时创建A   A和B之间是一一对应的（或者A独立）   由B生成的A是可以用过A.b找到这个原始的B，但是反过来B是找不到对应的A的。   三、代理模型   使用多表继承时，父类的每个子类都会创建一张新数据表，通常情况下，这是我们想要的操作，因为子类需要一个空间来存储不包含在父类中的数据。但有时，你可能只想更改模型在Python层面的行为，比如更改默认的manager管理器，或者添加一个新方法。   代理模型就是为此而生的。你可以创建、删除、更新代理模型的实例，并且所有的数据都可以像使用原始模型（非代理类模型）一样被保存。不同之处在于你可以在代理模型中改变默认的排序方式和默认的manager管理器等等，而不会对原始模型产生影响。   声明一个代理模型只需要将Meta中proxy的值设为True。   一些约束：      代理模型必须继承自一个非抽象的基类，并且不能同时继承多个非抽象基类；   代理模型可以同时继承任意多个抽象基类，前提是这些抽象基类没有定义任何模型字段。   代理模型可以同时继承多个别的代理模型，前提是这些代理模型继承同一个非抽象基类。（早期Django版本不支持这一条）   代理模型的管理器   如不指定，则继承父类的管理器。如果你自己定义了管理器，那它就会成为默认管理器，但是父类的管理器依然有效。如下例子：   from django.db import models  class NewManager(models.Manager):     # ...     pass  class MyPerson(Person):     objects = NewManager()      class Meta:         proxy = True   如果你想要向代理中添加新的管理器，而不是替换现有的默认管理器，你可以创建一个含有新的管理器的基类，并在继承时把他放在主基类的后面：   # Create an abstract class for the new manager. class ExtraManagers(models.Model):     secondary = NewManager()      class Meta:         abstract = True  class MyPerson(Person, ExtraManagers):     class Meta:         proxy = True   四、文件结构组织   在我们使用python manage.py startapp xxx命令创建新的应用时，Django会自动帮我们建立一个应用的基本文件组织结构，其中就包括一个models.py文件。通常，我们把当前应用的模型都编写在这个文件里，但是如果你的模型很多，那么将单独的models.py文件分割成一些独立的文件是个更好的做法。   首先，我们需要在应用中新建一个叫做models的包，再在包下创建一个__init__.py文件，这样才能确立包的身份。然后将models.py文件中的模型分割到一些.py文件中，比如organic.py和synthetic.py，然后删除models.py文件。最后在__init__.py文件中导入所有的模型。如下例所示：   #  myapp/models/__init__.py  from .organic import Person from .synthetic import Robot   要显式明确地导入每一个模型，而不要使用from .models import *的方式，这样不会混淆命名空间，让代码更可读，更容易被分析工具使用。  ","categories": ["note","Django"],
        "tags": [],
        "url": "http://localhost:4000/Django/Django-Model/",
        "teaser":null},{
        "title": "View in Django",
        "excerpt":"   URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应。     在Django项目中编写路由，就是向外暴露我们接收哪些URL的请求，除此之外的任何URL都不被处理，也没有返回。通俗地理解，不恰当的形容，URL路由是你的Web服务对外暴露的API。     Django奉行DRY主义，提倡使用简洁、优雅的URL，没有.php或.cgi这种后缀，更不会单独使用0、2097、1-1-1928、00这样无意义的东西，让你随心所欲设计你的URL，不受框架束缚。    一、概述   URL路由在Django项目中的体现就是urls.py文件，这个文件可以有很多个，但绝对不会在同一目录下。实际上Django提倡项目有个根urls.py，各app下分别有自己的一个urls.py，既集中又分治，是一种解耦的模式。   随便新建一个Django项目，默认会自动为我们创建一个/project_name/urls.py文件，并且自动包含下面的内容，这就是项目的根URL：   二、Django 如何处理请求   当用户请求一个页面时，Django根据下面的逻辑执行操作：      决定要使用的根URLconf模块。通常，这是ROOT_URLCONF设置的值，但是如果传入的HttpRequest对象具有urlconf属性（由中间件设置），则其值将被用于代替ROOT_URLCONF设置。通俗的讲，就是你可以自定义项目入口url是哪个文件！   加载该模块并寻找可用的urlpatterns。 它是django.urls.path()或者django.urls.re_path()实例的一个列表。   依次匹配每个URL模式，在与请求的URL相匹配的第一个模式停下来。也就是说，url匹配是从上往下的短路操作，所以url在列表中的位置非常关键。   导入并调用匹配行中给定的视图，该视图是一个简单的Python函数（被称为视图函数）,或基于类的视图。 视图将获得如下参数:            一个HttpRequest 实例。       如果匹配的表达式返回了未命名的组，那么匹配的内容将作为位置参数提供给视图。       关键字参数由表达式匹配的命名组组成，但是可以被django.urls.path()的可选参数kwargs覆盖。           如果没有匹配到任何表达式，或者过程中抛出异常，将调用一个适当的错误处理视图。   三、简单示例   先看一个例子：   from django.urls import path  from . import views  urlpatterns = [     path('articles/2003/', views.special_case_2003),     path('articles/&lt;int:year&gt;/', views.year_archive),     path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive),     path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/', views.article_detail), ]   注意：      要捕获一段url中的值，需要使用尖括号，而不是之前的圆括号；   可以转换捕获到的值为指定类型，比如例子中的int。默认情况下，捕获到的结果保存为字符串类型，不包含/这个特殊字符；   匹配模式的最开头不需要添加/，因为默认情况下，每个url都带一个最前面的/，既然大家都有的部分，就不用浪费时间特别写一个了。   匹配例子：      /articles/2005/03/ 将匹配第三条，并调用views.month_archive(request, year=2005, month=3)；   /articles/2003/匹配第一条，并调用views.special_case_2003(request)；   /articles/2003将一条都匹配不上，因为它最后少了一个斜杠，而列表中的所有模式中都以斜杠结尾；   /articles/2003/03/building-a-django-site/ 将匹配最后一个，并调用views.article_detail(request, year=2003, month=3, slug=”building-a-django-site”   每当urls.py文件被第一次加载的时候，urlpatterns里的表达式们都将被预先编译，这会大大提高系统处理路由的速度。   四、path转换器   默认情况下，Django内置下面的路径转换器：      str：匹配任何非空字符串，但不含斜杠/，如果你没有专门指定转换器，那么这个是默认使用的；   int：匹配0和正整数，返回一个int类型   slug：可理解为注释、后缀、附属等概念，是url拖在最后的一部分解释性字符。该转换器匹配任何ASCII字符以及连接符和下划线，比如building-your-1st-django-site；   uuid：匹配一个uuid格式的对象。为了防止冲突，规定必须使用破折号，所有字母必须小写，例如075194d3-6885-417e-a8a8-6c931e272f00。返回一个UUID对象；   path：匹配任何非空字符串，重点是可以包含路径分隔符’/‘。这个转换器可以帮助你匹配整个url而不是一段一段的url字符串。要区分path转换器和path()方法。   五、路由转发   通常，我们会在每个app里，各自创建一个urls.py路由模块，然后从根路由出发，将app所属的url请求，全部转发到相应的urls.py模块中。   例如，下面是Django网站本身的URLconf节选。 它包含许多其它URLconf：   from django.urls import include, path  urlpatterns = [     # ... 省略...     path('community/', include('aggregator.urls')),     path('contact/', include('contact.urls')),     # ... 省略 ... ]   路由转发使用的是include()方法，需要提前导入，它的参数是转发目的地路径的字符串，路径以圆点分割。   每当Django 遇到include()时，它会去掉URL中匹配的部分并将剩下的字符串发送给include的URLconf做进一步处理，也就是转发到二级路由去。   另外一种转发其它URL模式的方式是使用一个path()实例的列表。 例如，下面的URLconf：   from django.urls import include, path  from apps.main import views as main_views from credit import views as credit_views  extra_patterns = [     path('reports/', credit_views.report),     path('reports/&lt;int:id&gt;/', credit_views.report),     path('charge/', credit_views.charge), ]  urlpatterns = [     path('', main_views.homepage),     path('help/', include('apps.help.urls')),     path('credit/', include(extra_patterns)), ]   在此示例中，/credit/reports/URL将由credit_views.report()视图处理。这种做法，相当于把二级路由模块内的代码写到根路由模块里一起了，不是很推荐。   再看下面的URLconf：   from django.urls import path from . import views  urlpatterns = [     path('&lt;page_slug&gt;-&lt;page_id&gt;/history/', views.history),     path('&lt;page_slug&gt;-&lt;page_id&gt;/edit/', views.edit),     path('&lt;page_slug&gt;-&lt;page_id&gt;/discuss/', views.discuss),     path('&lt;page_slug&gt;-&lt;page_id&gt;/permissions/', views.permissions), ]   上面的路由写得不好，我们可以改进它，只需要声明共同的路径前缀一次，并将后面的部分分组转发：   from django.urls import include, path from . import views  urlpatterns = [     path('&lt;page_slug&gt;-&lt;page_id&gt;/', include([         path('history/', views.history),         path('edit/', views.edit),         path('discuss/', views.discuss),         path('permissions/', views.permissions),     ])), ]   这样就优雅多了，也清爽多了，但前提是你要理解这种做法。   六、传递参数   目的地URLconf会收到来自父URLconf捕获的所有参数，看下面的例子：   # In settings/urls/main.py from django.urls import include, path  urlpatterns = [     path('&lt;username&gt;/blog/', include('foo.urls.blog')), ]  # In foo/urls/blog.py from django.urls import path from . import views  urlpatterns = [     path('', views.blog.index),     path('archive/', views.blog.archive), ]   在上面的例子中，捕获的”username”变量将被传递给include()指向的URLconf，再进一步传递给对应的视图。   URLconfs具有一个钩子（hook），允许你传递一个Python字典作为额外的关键字参数给视图函数，像下面这样：   from django.urls import path from . import views  urlpatterns = [     path('blog/&lt;int:year&gt;/', views.year_archive, {'foo': 'bar'}), ]   在上面的例子中，对于/blog/2005/请求，Django将调用views.year_archive(request, year='2005', foo='bar')。理论上，你可以在这个字典里传递任何你想要的传递的东西。但是要注意，URL模式捕获的命名关键字参数和在字典中传递的额外参数有可能具有相同的名称，这会发生冲突，要避免。   七、Django内置的快捷方法   Django在django.shortcuts模块中，为我们提供了很多快捷方便的类和方法，它们都很重要，使用频率很高。   render   render(request, template_name, context=None, content_type=None, status=None, using=None)[source]   结合一个给定的模板和一个给定的上下文字典，返回一个渲染后的HttpResponse对象。   必需参数：      request：视图函数处理的当前请求，封装了请求头的所有数据，其实就是视图参数request。   template_name：要使用的模板的完整名称或者模板名称的列表。如果是一个列表，将使用其中能够查找到的第一个模板。   可选参数：      context：添加到模板上下文的一个数据字典。默认是一个空字典。可以将认可需要提供给模板的数据以字典的格式添加进去。这里有个小技巧，使用Python内置的locals()方法，可以方便的将函数作用于内的所有变量一次性添加。   content_type：用于生成的文档的MIME类型。 默认为DEFAULT_CONTENT_TYPE设置的值。   status：响应的状态代码。 默认为200。   using：用于加载模板使用的模板引擎的NAME。   范例：   下面的例子将渲染模板myapp/index.html，MIME类型为application/xhtml+xml：   from django.shortcuts import render  def my_view(request):     # View code here...     return render(request, 'myapp/index.html', {         'foo': 'bar',     }, content_type='application/xhtml+xml')   这个示例等同于：   from django.http import HttpResponse from django.template import loader  def my_view(request):     # View code here...     t = loader.get_template('myapp/index.html')     c = {'foo': 'bar'}     return HttpResponse(t.render(c, request), content_type='application/xhtml+xml')   render_to_response()   render_to_response(template_name, context=None, content_type=None, status=None, using=None)[source]   此功能在引入render()之前进行，不推荐，以后可能会被弃用。   redirect()   redirect(to, permanent=False, args, *kwargs)[source]   根据传递进来的url参数，返回HttpResponseRedirect。   参数to可以是：      一个模型：将调用模型的get_absolute_url()函数，反向解析出目的url；   视图名称：可能带有参数：reverse()将用于反向解析url；   一个绝对的或相对的URL：将原封不动的作为重定向的目标位置。   默认情况下是临时重定向，如果设置permanent=True将永久重定向。   范例：   1.调用对象的get_absolute_url()方法来重定向URL：   from django.shortcuts import redirect  def my_view(request):     ...     object = MyModel.objects.get(...)     return redirect(object)   2.传递视图名，使用reverse()方法反向解析url：   def my_view(request):     ...     return redirect('some-view-name', foo='bar')      重定向到硬编码的URL：   def my_view(request):     ...     return redirect('/some/url/')      重定向到一个完整的URL：   def my_view(request):     ...     return redirect('https://example.com/')   所有上述形式都接受permanent参数；如果设置为True，将返回永久重定向：   def my_view(request):     ...     object = MyModel.objects.get(...)     return redirect(object, permanent=True)   get_object_or_404()   get_object_or_404(klass, args, *kwargs)[source]   这个方法，非常有用，请一定熟记。常用于查询某个对象，找到了则进行下一步处理，如果未找到则给用户返回404页面。   在后台，Django其实是调用了模型管理器的get()方法，只会返回一个对象。不同的是，如果get()发生异常，会引发Http404异常，从而返回404页面，而不是模型的DoesNotExist异常。   必需参数：      class：要获取的对象的Model类名或者Queryset等；   **kwargs:查询的参数，格式应该可以被get()接受。   范例：   1.从MyModel中使用主键1来获取对象：   from django.shortcuts import get_object_or_404  def my_view(request):     my_object = get_object_or_404(MyModel, pk=1)   这个示例等同于：   from django.http import Http404  def my_view(request):     try:         my_object = MyModel.objects.get(pk=1)     except MyModel.DoesNotExist:         raise Http404(\"No MyModel matches the given query.\")   2.除了传递Model名称，还可以传递一个QuerySet实例：   queryset = Book.objects.filter(title__startswith='M') get_object_or_404(queryset, pk=1)   上面的示例不够简洁，因为它等同于：   get_object_or_404(Book, title__startswith='M', pk=1)   但是如果你的queryset来自其它地方，它就会很有用了。   3.还可以使用Manager。 如果你自定义了管理器，这将很有用：   get_object_or_404(Book.dahl_objects, title='Matilda')   4.还可以使用related managers：   author = Author.objects.get(name='Roald Dahl') get_object_or_404(author.book_set, title='Matilda')   与get()一样，如果找到多个对象将引发一个MultipleObjectsReturned异常。   5. get_list_or_404()   get_list_or_404(klass, args, *kwargs)[source]   这其实就是get_object_or_404多值获取版本。   在后台，返回一个给定模型管理器上filter()的结果，并将结果映射为一个列表，如果结果为空则弹出Http404异常。   必需参数：      klass：获取该列表的一个Model、Manager或QuerySet实例。   **kwargs：查询的参数，格式应该可以被filter()接受。   ","categories": ["note","Django"],
        "tags": [],
        "url": "http://localhost:4000/Django/Django-View/",
        "teaser":null},{
        "title": "Query in Django",
        "excerpt":"   refer : http://www.liujiangblog.com/course/django/129    查询操作是Django的ORM框架中最重要的内容之一。Django自动为所有的模型提供了一套完善、方便、高效的API     以如下的博客应用为模型：   from django.db import models  class Blog(models.Model):     name = models.CharField(max_length=100)     tagline = models.TextField()      def __str__(self):              # __unicode__ on Python 2         return self.name  class Author(models.Model):     name = models.CharField(max_length=200)     email = models.EmailField()      def __str__(self):              # __unicode__ on Python 2         return self.name  class Entry(models.Model):     blog = models.ForeignKey(Blog, on_delete=models.CASCADE)     headline = models.CharField(max_length=255)     body_text = models.TextField()     pub_date = models.DateField()     mod_date = models.DateField()     authors = models.ManyToManyField(Author)     n_comments = models.IntegerField()     n_pingbacks = models.IntegerField()     rating = models.IntegerField()      def __str__(self):              # __unicode__ on Python 2         return self.headline   一、创建对象与保存   创建对象   &gt;&gt;&gt; from blog.models import Blog &gt;&gt;&gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.') &gt;&gt;&gt; b.save()   运行save之后，后台会运行一条SQL的INSERT语句，save()方法没有返回值，它可以接受一些额外的参数.   也可以使用xxx.objects.create()代替上面的操作   外键和多字段   保存一个外键字段和保存普通字段一样，只要正确赋值然后调用save方法进行保存就好   对于多字段的保存稍微有点区别，需要调用一个add()方法，而不是直接给属性赋值，但它不需要调用save方法   &gt;&gt;&gt; from blog.models import Author &gt;&gt;&gt; joe = Author.objects.create(name=\"Joe\") &gt;&gt;&gt; entry.authors.add(joe)   在一行语句内，可以同时添加多个对象到多对多的字段，如下所示：   &gt;&gt;&gt; john = Author.objects.create(name=\"John\") &gt;&gt;&gt; paul = Author.objects.create(name=\"Paul\") &gt;&gt;&gt; george = Author.objects.create(name=\"George\") &gt;&gt;&gt; ringo = Author.objects.create(name=\"Ringo\") &gt;&gt;&gt; entry.authors.add(john, paul, george, ringo)   如果你指定或添加了错误类型的对象，Django会抛出异常。   二、检索对象   想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）构造一个查询结果集（QuerySet）。   每个QuerySet代表一些数据库对象的集合。它可以包含零个、一个或多个过滤器（filters）。Filters缩小查询结果的范围。在SQL语法中，一个QuerySet相当于一个SELECT语句，而filter则相当于WHERE或者LIMIT一类的子句。   通过模型的Manager获得QuerySet，每个模型至少具有一个Manager，默认情况下，它被称作objects，可以通过模型类直接调用它，但不能通过模型类的实例调用它，以此实现“表级别”操作和“记录级别”操作的强制分离。如下所示：   &gt;&gt;&gt; Blog.objects &lt;django.db.models.manager.Manager object at ...&gt; &gt;&gt;&gt; b = Blog(name='Foo', tagline='Bar') &gt;&gt;&gt; b.objects Traceback: ... AttributeError: \"Manager isn't accessible via Blog instances.\"   检索所有对象   all_entries = Entry.objects.all()   过滤对象   有两个方法可以用来过滤QuerySet的结果，分别是：      filter(**kwargs)：返回一个根据指定参数查询出来的QuerySet   exclude(**kwargs)：返回除了根据指定参数查询出来结果的QuerySet   其中，**kwargs参数的格式必须是Django设置的一些字段格式。   例如：   Entry.objects.filter(pub_date__year=2006)   它等同于：   Entry.objects.all().filter(pub_date__year=2006)   链式过滤   filter和exclude的结果依然是个QuerySet，因此它可以继续被filter和exclude，这就形成了链式过滤：   &gt;&gt;&gt; Entry.objects.filter( ...     headline__startswith='What' ... ).exclude( ...     pub_date__gte=datetime.date.today() ... ).filter( ...     pub_date__gte=datetime(2005, 1, 30) ... )   （这里需要注意的是，当在进行跨关系的链式过滤时，结果可能和你想象的不一样，参考下面的跨多值关系查询）   被过滤的QuerySets都是唯一的   每一次过滤，你都会获得一个全新的QuerySet，它和之前的QuerySet没有任何关系，可以完全独立的被保存，使用和重用。例如：   &gt;&gt;&gt; q1 = Entry.objects.filter(headline__startswith=\"What\") &gt;&gt;&gt; q2 = q1.exclude(pub_date__gte=datetime.date.today()) &gt;&gt;&gt; q3 = q1.filter(pub_date__gte=datetime.date.today())   例子中的q2和q3虽然由q1得来，是q1的子集，但是都是独立自主存在的。同样q1也不会受到q2和q3的影响。   QuerySets都是懒惰的   一个创建QuerySets的动作不会立刻导致任何的数据库行为。你可以不断地进行filter动作一整天，Django不会运行任何实际的数据库查询动作，直到QuerySets被提交(evaluated)。   简而言之就是，只有碰到某些特定的操作，Django才会将所有的操作体现到数据库内，否则它们只是保存在内存和Django的层面中。这是一种提高数据库查询效率，减少操作次数的优化设计。看下面的例子：   &gt;&gt;&gt; q = Entry.objects.filter(headline__startswith=\"What\") &gt;&gt;&gt; q = q.filter(pub_date__lte=datetime.date.today()) &gt;&gt;&gt; q = q.exclude(body_text__icontains=\"food\") &gt;&gt;&gt; print(q)   上面的例子，看起来执行了3次数据库访问，实际上只是在print语句时才执行1次访问。通常情况，QuerySets的检索不会立刻执行实际的数据库查询操作，直到出现类似print的请求，也就是所谓的evaluated。   检索单一对象   filter方法始终返回的是QuerySets，那怕只有一个对象符合过滤条件，返回的也是包含一个对象的QuerySets，这是一个集合类型对象，你可以简单的理解为Python列表，可迭代可循环可索引。   如果你确定你的检索只会获得一个对象，那么你可以使用Manager的get()方法来直接返回这个对象。   &gt;&gt;&gt; one_entry = Entry.objects.get(pk=1)   在get方法中你可以使用任何filter方法中的查询参数，用法也是一模一样。   注意：使用get()方法和使用filter()方法然后通过[0]的方式分片，有着不同的地方。看似两者都是获取单一对象。但是，如果在查询时没有匹配到对象，那么get()方法将抛出DoesNotExist异常。这个异常是模型类的一个属性，在上面的例子中，如果不存在主键为1的Entry对象，那么Django将抛出Entry.DoesNotExist异常。   类似地，在使用get()方法查询时，如果结果超过1个，则会抛出MultipleObjectsReturned异常，这个异常也是模型类的一个属性。   所以：get()方法要慎用！   使用限制   通常情况，切片操作会返回一个新的QuerySet，并且不会被立刻执行。但是有一个例外，那就是指定步长的时候，查询操作会立刻在数据库内执行，如下：   &gt;&gt;&gt; Entry.objects.all()[:10:2]   若要获取单一的对象而不是一个列表（例如，SELECT foo FROM bar LIMIT 1），可以简单地使用索引而不是切片。例如，下面的语句返回数据库中根据标题排序后的第一条Entry：   &gt;&gt;&gt; Entry.objects.order_by('headline')[0]   它相当于：   &gt;&gt;&gt; Entry.objects.order_by('headline')[0:1].get()   注意：如果没有匹配到对象，那么第一种方法会抛出IndexError异常，而第二种方式会抛出DoesNotExist异常。   也就是说在使用get和切片的时候，要注意查询结果的元素个数。   字段查询   字段查询其实就是filter()、exclude()和get()等方法的关键字参数。 其基本格式是：field__lookuptype=value，注意其中是双下划线。 例如：   &gt;&gt;&gt; Entry.objects.filter(pub_date__lte='2006-01-01') #　相当于： SELECT * FROM blog_entry WHERE pub_date &lt;= '2006-01-01';   其中的字段必须是模型中定义的字段之一。但是有一个例外，那就是ForeignKey字段，你可以为其添加一个“_id”后缀（单下划线）。这种情况下键值是外键模型的主键原生值。例如：   &gt;&gt;&gt; Entry.objects.filter(blog_id=4)   如果你传递了一个非法的键值，查询函数会抛出TypeError异常。   Django的数据库API支持20多种查询类型，下面介绍一些常用的：                  look up type       usage                       exact       默认类型                 iexact       不区分大小写                 contains       包含，大小写敏感                 icontains       包含，不区分大小写                 stratswith,endstiwith       字面意思                 istartswith,iendswith       字面意思，不区分大小写           跨关系查询   Django提供了强大并且直观的方式解决跨越关联的查询，它在后台自动执行包含JOIN的SQL语句。要跨越某个关联，只需使用关联的模型字段名称，并使用双下划线分隔，直至你想要的字段（可以链式跨越，无限跨度）。例如：   # 返回所有Blog的name为'Beatles Blog'的Entry对象 # 一定要注意，返回的是Entry对象，而不是Blog对象。 # objects前面用的是哪个class，返回的就是哪个class的对象。 &gt;&gt;&gt; Entry.objects.filter(blog__name='Beatles Blog')   反之亦然，如果要引用一个反向关联，只需要使用模型的小写名!   # 获取所有的Blog对象，前提是它所关联的Entry的headline包含'Lennon' &gt;&gt;&gt; Blog.objects.filter(entry__headline__contains='Lennon')   如果你在多级关联中进行过滤而且其中某个中间模型没有满足过滤条件的值，Django将把它当做一个空的（所有的值都为NULL）但是合法的对象，不会抛出任何异常或错误。例如，在下面的过滤器中：   Blog.objects.filter(entry__authors__name='Lennon')   如果Entry中没有关联任何的author，那么它将当作其没有name，而不会因为没有author 引发一个错误。通常，这是比较符合逻辑的处理方式。唯一可能让你困惑的是当你使用isnull的时候：   Blog.objects.filter(entry__authors__name__isnull=True)   这将返回Blog对象，它关联的entry对象的author字段的name字段为空，以及Entry对象的author字段为空。如果你不需要后者，你可以这样写：   Blog.objects.filter(entry__authors__isnull=False,entry__autho   跨越多值的关系查询   最基本的filter和exclude的关键字参数只有一个，这种情况很好理解。但是当关键字参数有多个，且是跨越外键或者多对多的情况下，那么就比较复杂，让人迷惑了。我们看下面的例子：   Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)   这是一个跨外键、两个过滤参数的查询。此时我们理解两个参数之间属于-与“and”的关系，也就是说，过滤出来的BLog对象对应的entry对象必须同时满足上面两个条件。这点很好理解。也就是说上面要求至少有一个entry同时满足两个条件。   但是，看下面的用法：   Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)   把两个参数拆开，放在两个filter调用里面，按照我们前面说过的链式过滤，这个结果应该和上面的例子一样。可实际上，它不一样，Django在这种情况下，将两个filter之间的关系设计为-或“or”，这真是让人头疼。   多对多关系下的多值查询和外键foreignkey的情况一样。   但是，更头疼的来了，exclude的策略设计的又和filter不一样！   Blog.objects.exclude(entry__headline__contains='Lennon',entry__pub_date__year=2008,)   这会排除headline中包含“Lennon”的Entry和在2008年发布的Entry，中间是一个-和“or”的关系！   那么要排除同时满足上面两个条件的对象，该怎么办呢？看下面：   Blog.objects.exclude( entry=Entry.objects.filter(     headline__contains='Lennon',     pub_date__year=2008, ), )   （有没有很坑爹的感觉？所以，建议在碰到跨关系的多值查询时，尽量使用Q查询）   快捷查询 pk   pk就是primary key的缩写。通常情况下，一个模型的主键为“id”，所以下面三个语句的效果一样：   &gt;&gt;&gt; Blog.objects.get(id__exact=14) # Explicit form &gt;&gt;&gt; Blog.objects.get(id=14) # __exact is implied &gt;&gt;&gt; Blog.objects.get(pk=14) # pk implies id__exact   三、使用Q对象进行复杂查询   普通filter函数里的条件都是“and”逻辑，如果你想实现“or”逻辑怎么办？用Q查询！   Q来自django.db.models.Q，用于封装关键字参数的集合，可以作为关键字参数用于filter、exclude和get等函数。 例如：   from django.db.models import Q Q(question__startswith='What')                  可以使用“&amp;”或者“       ”或“~”来组合Q对象，分别表示与或非逻辑。它将返回一个新的Q对象。           Q(question__startswith='Who')|Q(question__startswith='What') # 这相当于： WHERE question LIKE 'Who%' OR question LIKE 'What%'   更多的例子：   Q(question__startswith='Who') | ~Q(pub_date__year=2005)   你也可以这么使用，默认情况下，以逗号分隔的都表示AND关系：   Poll.objects.get( Q(question__startswith='Who'), Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)) ) # 它相当于 # SELECT * from polls WHERE question LIKE 'Who%' AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')   当关键字参数和Q对象组合使用时，Q对象必须放在前面，如下例子：   Poll.objects.get( Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),question__startswith='Who',)   如果关键字参数放在Q对象的前面，则会报错。   四、比较对象   要比较两个模型实例，只需要使用python提供的双等号比较符就可以了。在后台，其实比较的是两个实例的主键的值。下面两种方法是等同的：   &gt;&gt;&gt; some_entry == other_entry &gt;&gt;&gt; some_entry.id == other_entry.id   如果模型的主键不叫做“id”也没关系，后台总是会使用正确的主键名字进行比较，例如，如果一个模型的主键的名字是“name”，那么下面是相等的：   &gt;&gt;&gt; some_obj == other_obj &gt;&gt;&gt; some_obj.name == other_obj.name   五、删除对象   删除对象使用的是对象的delete()方法。该方法将返回被删除对象的总数量和一个字典，字典包含了每种被删除对象的类型和该类型的数量。如下所示：   &gt;&gt;&gt; e.delete() (1, {'weblog.Entry': 1})   也可以批量删除。每个QuerySet都有一个delete()方法，它能删除该QuerySet的所有成员。例如：   &gt;&gt;&gt; Entry.objects.filter(pub_date__year=2005).delete() (5, {'webapp.Entry': 5})   需要注意的是，有可能不是每一个对象的delete方法都被执行。如果你改写了delete方法，为了确保对象被删除，你必须手动迭代QuerySet进行逐一删除操作。   当Django删除一个对象时，它默认使用SQL的ON DELETE CASCADE约束，也就是说，任何有外键指向要删除对象的对象将一起被删除。例如：   b = Blog.objects.get(pk=1) # 下面的动作将删除该条Blog和所有的它关联的Entry对象 b.delete()   这种级联的行为可以通过的ForeignKey的on_delete参数自定义。   注意，delete()是唯一没有在管理器上暴露出来的方法。这是刻意设计的一个安全机制，用来防止你意外地请求类似Entry.objects.delete()的动作，而不慎删除了所有的条目。如果你确实想删除所有的对象，你必须明确地请求一个完全的查询集，像下面这样：   Entry.objects.all().delete()   六、更多关于QuerySet   何时被提交？   在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。   可以使用下列方法对QuerySet提交查询操作：      迭代   QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的headline打印出来：   for e in Entry.objects.all():     print(e.headline)      切片：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。   Pickling/缓存   repr()   len()：当你对QuerySet调用len()时， 将提交数据库操作。   list()：对QuerySet调用list()将强制提交操作entry_list = list(Entry.objects.all())   bool()   测试布尔值，像这样：   if Entry.objects.filter(headline=\"Test\"):    print(\"There is at least one Entry with the headline Test\")   注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用exists() 将更加高效。   返回新的QuerySets的API   以下的方法都将返回一个新的QuerySets。重点是加粗的几个API，其它的使用场景很少。                  方法名       解释                       filter()       过滤查询对象。                 exclude()       排除满足条件的对象                 annotate()       使用聚合函数                 order_by()       对查询集进行排序                 reverse()       反向排序                 distinct()       对查询集去重                 values()       返回包含对象具体值的字典的QuerySet                 values_list()       与values()类似，只是返回的是元组而不是字典。                 dates()       根据日期获取查询集                 datetimes()       根据时间获取查询集                 none()       创建空的查询集                 all()       获取所有的对象                 union()       并集                 intersection()       交集                 difference()       差集                 select_related()       附带查询关联对象                 prefetch_related()       预先查询                 extra()       附加SQL查询                 defer()       不加载指定字段                 only()       只加载指定的字段                 using()       选择数据库                 select_for_update()       锁住选择的对象，直到事务结束。                 raw()       接收一个原始的SQL查询           filter()   filter(**kwargs)   返回满足查询参数的对象集合。   查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数之间是和AND的关系。   exclude()   exclude(**kwargs)   返回一个新的QuerySet，它包含不满足给定的查找参数的对象。   查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数通过AND连接，然后所有的内容放入NOT() 中。   下面的示例排除所有pub_date晚于2005-1-3且headline为“Hello” 的记录：   Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')   下面的示例排除所有pub_date晚于2005-1-3或者headline 为“Hello” 的记录：   Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).   annotate()   annotate(args, *kwargs)   使用提供的聚合表达式查询对象。   表达式可以是简单的值、对模型（或任何关联模型）上的字段的引用或者聚合表达式（平均值、总和等）。   annotate()的每个参数都是一个annotation，它将添加到返回的QuerySet每个对象中。   关键字参数指定的Annotation将使用关键字作为Annotation 的别名。 匿名参数的别名将基于聚合函数的名称和模型的字段生成。 只有引用单个字段的聚合表达式才可以使用匿名参数。 其它所有形式都必须用关键字参数。   例如，如果正在操作一个Blog列表，你可能想知道每个Blog有多少Entry：   &gt;&gt;&gt; from django.db.models import Count &gt;&gt;&gt; q = Blog.objects.annotate(Count('entry')) # The name of the first blog &gt;&gt;&gt; q[0].name 'Blogasaurus' # The number of entries on the first blog &gt;&gt;&gt; q[0].entry__count 42   Blog模型本身没有定义entry__count属性，但是通过使用一个关键字参数来指定聚合函数，可以控制Annotation的名称：   &gt;&gt;&gt; q = Blog.objects.annotate(number_of_entries=Count('entry')) # The number of entries on the first blog, using the name provided &gt;&gt;&gt; q[0].number_of_entries 42   order_by()   order_by(*fields)   默认情况下，根据模型的Meta类中的ordering属性对QuerySet中的对象进行排序   Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')   上面的结果将按照pub_date降序排序，然后再按照headline升序排序。”-pub_date”前面的负号表示降序顺序。 升序是默认的。 要随机排序，使用”?”，如下所示：   Entry.objects.order_by('?')   注：order_by('?')可能耗费资源且很慢，这取决于使用的数据库。   若要按照另外一个模型中的字段排序，可以使用查询关联模型的语法。即通过字段的名称后面跟两个下划线（__），再加上新模型中的字段的名称，直到希望连接的模型。 像这样：   Entry.objects.order_by('blog__name', 'headline')   如果排序的字段与另外一个模型关联，Django将使用关联的模型的默认排序，或者如果没有指定Meta.ordering将通过关联的模型的主键排序。 例如，因为Blog模型没有指定默认的排序：   Entry.objects.order_by('blog')   与以下相同：   Entry.objects.order_by('blog__id')   如果Blog设置了ordering = ['name']，那么第一个QuerySet将等同于：   Entry.objects.order_by('blog__name')   还可以通过调用表达式的desc()或者asc()方法：   Entry.objects.order_by(Coalesce('summary', 'headline').desc())   考虑下面的情况，指定一个多值字段来排序（例如，一个ManyToManyField 字段或者ForeignKey 字段的反向关联）：   class Event(Model):    parent = models.ForeignKey(        'self',        on_delete=models.CASCADE,        related_name='children',    )    date = models.DateField()  Event.objects.order_by('children__date')   在这里，每个Event可能有多个排序数据；具有多个children的每个Event将被多次返回到order_by()创建的新的QuerySet中。 换句话说，用order_by()方法对QuerySet对象进行操作会返回一个扩大版的新QuerySet对象。因此，使用多值字段对结果进行排序时要格外小心。   没有方法指定排序是否考虑大小写。 对于大小写的敏感性，Django将根据数据库中的排序方式排序结果。   可以通过Lower将一个字段转换为小写来排序，它将达到大小写一致的排序：   Entry.objects.order_by(Lower('headline').desc())   可以通过检查QuerySet.ordered属性来知道查询是否是排序的。   每个order_by()都将清除前面的任何排序。 例如下面的查询将按照pub_date排序，而不是headline：   Entry.objects.order_by('headline').order_by('pub_date')   reverse()   reverse()   反向排序QuerySet中返回的元素。 第二次调用reverse()将恢复到原有的排序。   如要获取QuerySet中最后五个元素，可以这样做：   my_queryset.reverse()[:5]   这与Python直接使用负索引有点不一样。 Django不支持负索引，只能曲线救国。   union()   union(*other_qs, all=False)   Django中的新功能1.11。也就是集合中并集的概念！   使用SQL的UNION运算符组合两个或更多个QuerySet的结果。例如：   &gt;&gt;&gt; qs1.union(qs2, qs3)   默认情况下，UNION操作符仅选择不同的值。 要允许重复值，请使用all=True参数。   intersection()   intersection(*other_qs)   Django中的新功能1.11。也就是集合中交集的概念！   使用SQL的INTERSECT运算符返回两个或更多个QuerySet的共有元素。例如：   &gt;&gt;&gt; qs1.intersection(qs2, qs3)   select_for_update()   select_for_update(nowait=False, skip_locked=False)   返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个SELECT ... FOR UPDATE语句。   例如：   entries = Entry.objects.select_for_update().filter(author=request.user)   所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。   一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。使用select_for_update(nowait=True)将使查询不阻塞。如果其它事务持有冲突的锁,那么查询将引发DatabaseError异常。也可以使用select_for_update(skip_locked=True)忽略锁定的行。nowait和skip_locked是互斥的。   目前，postgresql，oracle和mysql数据库后端支持select_for_update()。但是，MySQL不支持nowait和skip_locked参数。   不返回QuerySets的API                  方法名       解释                       get()       获取单个对象                 create()       创建对象，无需save()                 get_or_create()       查询对象，如果没有找到就新建对象                 update_or_create()       更新对象，如果没有找到就创建对象                 bulk_create()       批量创建对象                 count()       统计对象的个数                 in_bulk()       根据主键值的列表，批量返回对象                 iterator()       获取包含对象的迭代器                 latest()       获取最近的对象                 earliest()       获取最早的对象                 first()       获取第一个对象                 last()       获取最后一个对象                 aggregate()       聚合操作                 exists()       判断queryset中是否有对象                 update()       批量更新对象                 delete()       批量删除对象                 as_manager()       获取管理器           ","categories": ["note","Django"],
        "tags": [],
        "url": "http://localhost:4000/Django/Django-Query/",
        "teaser":null},{
        "title": "REST framework — Serializer & ViewSets",
        "excerpt":"Serializer      refer : https://q1mi.github.io/Django-REST-framework-documentation/tutorial/1-serialization_zh/#model    开发我们的Web API的第一件事是为我们的Web API提供一种将代码片段实例序列化和反序列化为诸如json之类的表示形式的方式。我们可以通过声明与Django forms非常相似的序列化器（serializers）来实现。 在snippets的目录下创建一个名为serializers.py文件，并添加以下内容。   from rest_framework import serializers from snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES   class SnippetSerializer(serializers.Serializer):     id = serializers.IntegerField(read_only=True)     title = serializers.CharField(required=False, allow_blank=True, max_length=100)     code = serializers.CharField(style={'base_template': 'textarea.html'})     linenos = serializers.BooleanField(required=False)     language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python')     style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly')      def create(self, validated_data):         \"\"\"         根据提供的验证过的数据创建并返回一个新的`Snippet`实例。         \"\"\"         return Snippet.objects.create(**validated_data)      def update(self, instance, validated_data):         \"\"\"         根据提供的验证过的数据更新和返回一个已经存在的`Snippet`实例。         \"\"\"         instance.title = validated_data.get('title', instance.title)         instance.code = validated_data.get('code', instance.code)         instance.linenos = validated_data.get('linenos', instance.linenos)         instance.language = validated_data.get('language', instance.language)         instance.style = validated_data.get('style', instance.style)         instance.save()         return instance   序列化器类的第一部分定义了序列化/反序列化的字段。create()和update()方法定义了在调用serializer.save()时如何创建和修改完整的实例。   序列化器类与Django Form类非常相似，并在各种字段中包含类似的验证标志，例如required，max_length和default。   字段标志还可以控制serializer在某些情况下如何显示，比如渲染HTML的时候。上面的{'base_template': 'textarea.html'}标志等同于在Django Form类中使用widget=widgets.Textarea。这对于控制如何显示可浏览器浏览的API特别有用，我们将在本教程的后面看到。   我们实际上也可以通过使用ModelSerializer类来节省时间，就像我们后面会用到的那样。但是现在我们还继续使用我们明确定义的serializer。   使用序列化类   在我们进一步了解之前，我们先来熟悉使用我们新的Serializer类。输入下面的命令进入Django shell。   python manage.py shell   好的，像下面一样导入几个模块，然后开始创建一些代码片段来处理。   from snippets.models import Snippet from snippets.serializers import SnippetSerializer from rest_framework.renderers import JSONRenderer from rest_framework.parsers import JSONParser  snippet = Snippet(code='foo = \"bar\"\\n') snippet.save()  snippet = Snippet(code='print \"hello, world\"\\n') snippet.save()   我们现在已经有几个片段实例了，让我们看一下将其中一个实例序列化。   serializer = SnippetSerializer(snippet) serializer.data # {'id': 2, 'title': u'', 'code': u'print \"hello, world\"\\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}   此时，我们将模型实例转换为Python原生数据类型。要完成序列化过程，我们将数据转换成json。   content = JSONRenderer().render(serializer.data) content # '{\"id\": 2, \"title\": \"\", \"code\": \"print \\\\\"hello, world\\\\\"\\\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"}'   反序列化是类似的。首先我们将一个流（stream）解析为Python原生数据类型…   from django.utils.six import BytesIO  stream = BytesIO(content) data = JSONParser().parse(stream)   …然后我们要将Python原生数据类型恢复成正常的对象实例。   serializer = SnippetSerializer(data=data) serializer.is_valid() # True serializer.validated_data # OrderedDict([('title', ''), ('code', 'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]) serializer.save() # &lt;Snippet: Snippet object&gt;   可以看到API和表单(forms)是多么相似。当我们开始使用我们的序列化类编写视图的时候，相似性会变得更加明显。   我们也可以序列化查询结果集（querysets）而不是模型实例。我们只需要为serializer添加一个many=True标志。   serializer = SnippetSerializer(Snippet.objects.all(), many=True) serializer.data # [OrderedDict([('id', 1), ('title', u''), ('code', u'foo = \"bar\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 2), ('title', u''), ('code', u'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 3), ('title', u''), ('code', u'print \"hello, world\"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])]   ✨✨使用ModelSerializers   我们的SnippetSerializer类中重复了很多包含在Snippet模型类（model）中的信息。如果能保证我们的代码整洁，那就更好了。   就像Django提供了Form类和ModelForm类一样，REST framework包括Serializer类和ModelSerializer类。   我们来看看使用ModelSerializer类重构我们的序列化类。再次打开snippets/serializers.py文件，并将SnippetSerializer类替换为以下内容。   class SnippetSerializer(serializers.ModelSerializer):     class Meta:         model = Snippet         fields = ('id', 'title', 'code', 'linenos', 'language', 'style')   序列一个非常棒的属性就是可以通过打印序列化器类实例的结构(representation)查看它的所有字段。   from snippets.serializers import SnippetSerializer serializer = SnippetSerializer() print(repr(serializer)) # SnippetSerializer(): #    id = IntegerField(label='ID', read_only=True) #    title = CharField(allow_blank=True, max_length=100, required=False) #    code = CharField(style={'base_template': 'textarea.html'}) #    linenos = BooleanField(required=False) #    language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')... #    style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')...   重要的是要记住，ModelSerializer类并不会做任何特别神奇的事情，它们只是创建序列化器类的快捷方式：      一组自动确定的字段。   默认简单实现的create()和update()方法。   Viewsets      refer : https://q1mi.github.io/Django-REST-framework-documentation/api-guide/viewsets_zh/    Django REST framework允许你将一组相关视图的逻辑组合在单个类（称为 ViewSet）中。 在其他框架中，你也可以找到概念上类似于 ‘Resources’ 或 ‘Controllers’的类似实现。   ViewSet 只是一种基于类的视图，它不提供任何方法处理程序（如 .get()或.post()）,而是提供诸如 .list() 和 .create() 之类的操作。   ViewSet 的方法处理程序仅使用 .as_view() 方法绑定到完成视图的相应操作。   通常不是在 urlconf 中的视图集中显示注册视图，而是要使用路由类注册视图集，该类会自动为你确定 urlconf。   Example   让我们定义一个简单的视图集，可以用来列出或检索系统中的所有用户。   from django.contrib.auth.models import User from django.shortcuts import get_object_or_404 from myapps.serializers import UserSerializer from rest_framework import viewsets from rest_framework.response import Response  class UserViewSet(viewsets.ViewSet):     \"\"\"     A simple ViewSet for listing or retrieving users.     \"\"\"     def list(self, request):         queryset = User.objects.all()         serializer = UserSerializer(queryset, many=True)         return Response(serializer.data)      def retrieve(self, request, pk=None):         queryset = User.objects.all()         user = get_object_or_404(queryset, pk=pk)         serializer = UserSerializer(user)         return Response(serializer.data)   如果我们需要，我们可以将这个viewset绑定到两个单独的视图，想这样：   user_list = UserViewSet.as_view({'get': 'list'}) user_detail = UserViewSet.as_view({'get': 'retrieve'})   通常我们不会这么做，我们会用一个router来注册我们的viewset，让urlconf自动生成。   from myapp.views import UserViewSet from rest_framework.routers import DefaultRouter  router = DefaultRouter() router.register(r'users', UserViewSet) urlpatterns = router.urls   不需要编写自己的视图集，你通常会想要使用提供默认行为的现有基类。例如：   class UserViewSet(viewsets.ModelViewSet):     \"\"\"     用于查看和编辑用户实例的视图集。     \"\"\"     serializer_class = UserSerializer     queryset = User.objects.all()   与使用 View 类相比，使用 ViewSet 类有两个主要优点。      重复的逻辑可以组合成一个类。在上面的例子中，我们只需要指定一次 queryset，它将在多个视图中使用。   通过使用 routers, 哦们不再需要自己处理URLconf。   这两者都有一个权衡。使用常规的 views 和 URL confs 更明确也能够为你提供更多的控制。ViewSets有助于快速启动和运行，或者当你有大型的API，并且希望在整个过程中执行一致的 URL 配置。   ViewSet   ViewSet 继承自 APIView。你可以使用任何标准属性，如 permission_classes, authentication_classes 以便控制视图集上的 API 策略。   ViewSet 类不提供任何操作的实现。为了使用 ViewSet 类，你将重写该类并显式地定义动作实现。   GenericViewSets   GenericViewSet 类继承自 GenericAPIView，并提供了 get_object， get_queryset 方法和其他通用视图基本行为的默认配置，但默认情况不包括任何操作。   In order to use a GenericViewSet class you’ll override the class and either mixin the required mixin classes, or define the action implementations explicitly.   ModelViewSet   The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.   The actions provided by the ModelViewSet class are .list(), .retrieve(),.create(), .update(), .partial_update(), and .destroy().   Example   Because ModelViewSet extends GenericAPIView, you’ll normally need to provide at least the queryset and serializer_class attributes. For example:   class AccountViewSet(viewsets.ModelViewSet):     \"\"\"     A simple ViewSet for viewing and editing accounts.     \"\"\"     queryset = Account.objects.all()     serializer_class = AccountSerializer     permission_classes = [IsAccountAdminOrReadOnly]   Note that you can use any of the standard attributes or method overrides provided by GenericAPIView. For example, to use a ViewSet that dynamically determines the queryset it should operate on, you might do something like this:   class AccountViewSet(viewsets.ModelViewSet):     \"\"\"     A simple ViewSet for viewing and editing the accounts     associated with the user.     \"\"\"     serializer_class = AccountSerializer     permission_classes = [IsAccountAdminOrReadOnly]      def get_queryset(self):         return self.request.user.accounts.all()   Note however that upon removal of the queryset property from your ViewSet, any associated router will be unable to derive the base_name of your Model automatically, and so you will have to specify the base_name kwarg as part of your router registration.   Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.   ","categories": ["note","Django"],
        "tags": [],
        "url": "http://localhost:4000/Django/Django-REST-framework-serializers/",
        "teaser":null},{
        "title": "Flask",
        "excerpt":"Flask 实战   Intro   Flask是一个基于python开发的开源框架，官方文档称其为”微”框架，表示Flask的目的是保持核心简单而又可扩展。Flask不会替你做出许多决定，不包含数据库抽象层、表单验证或者其他已有的库可以处理的东西。然而，Flask通过扩展为你的应用添加这些功能。   Usage   Install   pip install flask   完整的flask开发环境可能需要内容组件比较多, 可以将所有相关的包放置在一个txt文件，然后使用pip install -r requires.txt进行安装。   启动   from flask import Flask app = Flask(__name__)  @app.route('/') def hello_world():     return 'Hello, World!'      首先我们导入了Flask类。该类的实例将会成为我们WSGI应用。   接着我们创建一个该类的实例。第一个参数是应用模块或者包的名称。如果你使用 一个单一模块（就像本例），那么应当使用 __name__ ，因为名称会根据这个 模块是按应用方式使用还是作为一个模块导入而发生变化（可能是 ‘main’ ， 也可能是实际导入的名称）。这个参数是必需的，这样 Flask 才能知道在哪里可以 找到模板和静态文件等东西。更多内容详见 Flask 文档。   然后我们使用 route() 装饰器来告诉 Flask 触发函数的 URL 。   函数名称被用于生成相关联的 URL 。函数最后返回需要在用户浏览器中显示的信息。   初始化简介   # Flask实例的源码： class Flask(_PackageBoundObject):     def __init__(self, import_name,  # 指定应用的名字和工程目录，默认为__name__                 static_path=None,  # 是静态文件存放的路径，会赋值给static_url_path参数                 static_url_path=None,  # 设置静态文件路由的前缀，默认为“/static”                 static_folder='static', # 静态文件的存放目录， 默认值为\"static\"                 template_folder='templates', # 模板文件的存放目录，默认值为\"templates\"                 instance_path=None, # 设置配置文件的路径，instance_relative_config=True情况下生效                 instance_relative_config=False # 设置为True表示配置文件相对于实例路径而不是根路径                 root_path=None) # 应用程序的根路径   app.run(host=None, # 设置ip，默认127.0.0.1         port=None, # 设置端口，默认5000         debug=None)  # 设置是否开启调试，默认false   路由   FLask中，使用route()装饰器来把函数绑定到URL，下面是官方的例子：   @app.route('/') def index():     return 'Index Page'  @app.route('/hello') def hello():     return 'Hello, World'      @app.route('/user/&lt;username&gt;') def show_user_profile(username):     # show the user profile for that user     return 'User %s' % username  @app.route('/post/&lt;int:post_id&gt;') def show_post(post_id):     # show the post with the given id, the id is an integer     return 'Post %d' % post_id  @app.route('/path/&lt;path:subpath&gt;') def show_subpath(subpath):     # show the subpath after /path/     return 'Subpath %s' % subpath   通过把 URL 的一部分标记为 &lt;variable_name&gt; 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 &lt;converter:variable_name&gt; ，可以选择性的加上一个转换器。   转换器类型：                  string       （缺省值） 接受任何不包含斜杠的文本                       int       接受正整数                 float       接受正浮点数                 path       类似 string ，但可以包含斜杠                 uuid       接受 UUID 字符串           URL构建与查看   url_for()函数用于构建指定函数的URL。也可以使用url_for()获取某函数对应的URL。   @app.route('/loginto') def login():     print(url_for('login'))   # 会打印出网址中主机名后的部分     return 'Hello world!'   HTTP方法与参数获取   使用route装饰器的methods参数可以设置接收到get或post方法，缺省情况下，一个路由只回应GET请求：   from flask import request  @app.route('/login', methods=['GET', 'POST']) def login():     if request.method == 'POST':         return do_the_login()     else:         return show_the_login_form()   通过request.get_data()获得传输的数据包，然后转换为json格式：   from flask import request import json @app.route(\"/api/v1/login\", methods=['POST']) def login():     if request.method == 'POST':         data = request.get_data()         json_data = json.loads(data.decode('utf-8'))         print(json_data)   也可以使用form来处理表单信息：   @app.route('/login', methods=['POST', 'GET']) def login():     error = None     if request.method == 'POST':         if valid_login(request.form['username'],                        request.form['password']):             return log_the_user_in(request.form['username'])         else:             error = 'Invalid username/password'     # the code below is executed if the request method     # was GET or the credentials were invalid     return render_template('login.html', error=error)   最好使用get方法来访问表单中的属性，因为get在该属性不存在的时候会返回一个用户设定的缺省值。   内容返回   在进行查询的时候，我们会有大量的json格式的信息需要返回到前端进行处理：   import json @app.route('/hello', methods=['GET', 'POST']) def hello(): \tdata={'message':'hello',         'status':'ok'} \treturn json.dumps(data)   Session   使用session对象，允许你在不同请求之间存储信息。这个对象相当于用密钥签名加密的 cookie ，即用户可以查看你的 cookie ，但是如果没有密钥就无法修改它。   使用session之前必须设置一个密钥：   from flask import Flask, session, redirect, url_for, escape, request  app = Flask(__name__) app.secret_key = \"nQnk2n8moN=GLNmE.wL6PTZD\"  @app.route('/') def index():     if 'username' in session:         return 'Logged in as %s' % escape(session['username'])     return 'You are not logged in'    @app.route('/login', methods=['GET', 'POST']) def login():     if request.method == 'POST':         session['username'] = request.form['username']         return redirect(url_for('index'))        @app.route('/logout') def logout():     # remove the username from the session if it's there     session.pop('username', None)     return redirect(url_for('index'))   上面的代码使用Session实现登入的持久化。   跨域访问   当调用服务端的域名与服务端不一致(前后端分离)的时候会出现跨域问题，可使用Flask-Cors解决以上问题      使用这种方法只能返回json格式数据，list、ndarray等都不可以   返回的对象必须是字符串、元组、响应实例或WSGI可调用   安装Flask-Cors pip install Falsk-Cors   import flask import Flask from flask_cors import * app = Flask(__name__) CORS(app, supports_credentials=True))   Reference      Welcome to Flask — Flask 1.0.2 documentation   Flask-CORS — Flask-Cors 3.0.7 documentation  ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/LeiEarn/Flask/",
        "teaser":null},{
        "title": "Tmux",
        "excerpt":"帅气的使用终端，程序员利器 —— Tmux   ​\t在这次的项目开发中，我主要是进行架构设计与后台开发，我们的服务器部署在阿里云的云平台上所以少不了与Terminal打交道，对命令行下的开发速率要求较高   ​\t虽然在mac下使用iterm2极大的优化了terminal的使用体验（例如历史输入补全等功能),然而还是避免不了在与前端进行交互测试的时候，为了同时修改代码、启动程序、提交代码…等等操作，需要开启一堆terminal窗口，而Tmux的 Session恰好实现了这样的功能！   What’s Tmux   Tmux(termianl multiplexer) 是一个BSD协议发布的终端复用软件，用来在服务器端托管同时运行的Shell。使用该工具，用户可以连接或断开会话，而保持终端在后台运行。   Install   首先进行安装   brew install tmux       # OSX pacman -S tmux          # archlinux apt-get install tmux    # Ubuntu yum install tmux        # Centos   Usage   tmux的基本结构   ​\ttmux的结构包括会话(session)、窗口(window)、窗格(pane)三部分，会话的实质是伪终端的集合，每个窗格表示一个伪终端，多个窗格显示在一个屏幕上，这一屏幕就叫窗口。如图：      tmux的基本操作   ​\ttmux的基本操作，无非就是用会话、窗口、窗格进行管理，包括创建、关闭、重命名、连接、分离、选择等等。   Session 操作   创建session   tmux new -s {session_name}   使用&lt;prefix&gt; $可以重命名当前的Session，其中&lt;prefix&gt;指的是tmux中的前缀键，默认值是Ctrl+b。   显示会话列表   tmux ls   连接上一个会话   tmux a or tmux attach   连接指定会话   tmux a -t {session_name}   关闭指定会话   tmux kill-session -t {session_name}   在&lt;会话中列出所有session并切换   &lt;prefix&gt; s   以上的指令都是对session的操作，涵盖了基本的session操作，在本次项目中已经很够用了。接下来是进入到会话后的一些使用的快捷键。   window 操作   创建一个新窗口   &lt;prefix&gt; c   列出所有窗口，并切换   &lt;prefix&gt; w   pane 操作   在项目的过程中，我对窗口的操作并不频繁，主要运用的还是窗口分割成多个pane的技术   水平方向创建窗格   &lt;prefix&gt; %   垂直方向创建窗格   &lt;prefix&gt; \"   切换窗格   &lt;prefix&gt; Up|Down|Left|Rgith  #方向键   关闭当前窗格   &lt;prefix&gt; x   重新排列当前窗口下的所有窗格   &lt;prefix&gt; space \t\t#\t空格键   总的来说，上面这5个操作简直是神器，极大的提高了开发和测试的效率，比如说可以分出一个窗格看Flask服务器的输出，另一个窗格用于查看数据库内容，另一个窗格用来修改代码，或者甚至还可以分出一个窗格用crul指令自己对服务器进行测试。   滚动窗格   &lt;prefix&gt; [   这个快捷键也非常重要，因为在tmux会话中无法使用滚轮或上下键来滚动显示之前的terminal内容，使用该快捷键可以冻结当前的面板内容，查看之前的全部内容，按Ctrl + c退出。   其他命令   列出所有命令   tmux list-command   使用UTF-8   tmux -u   显示时钟   &lt;prefix&gt; t   MORE      TMUX与Screen的区别   使用Vim和Tmux搭建一个IDE   Mac 下的Tmux配置   引用：           tmux基本操作            Tmux使用手册| louis blog            优雅地使用命令行：Tmux 终端复用       ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/LeiEarn/Tmux/",
        "teaser":null},{
        "title": "Spark Note",
        "excerpt":"Apache Spark 是目前处理和使用大数据的最广泛使用的框架之一，Python是数据分析、机器学习等最广泛使用的编程语言之一。为了用Spark支持Python，Apache Spark社区发布了一个工具PySpark。使用PySpark，您也可以使用Python编程语言处理RDD。正是由于一个名为Py4j的库，他们才能实现这一目标。   Apache Spark是Apache Software Foundation开发的用于实时处理的开源集群计算框架。 Spark提供了一个接口，用于编程具有隐式数据并行和容错功能的集群。   SparkContent   SparkContext是任何spark功能的入口点。当我们运行任何Spark应用程序时，会启动一个驱动程序，它具有main函数，并且此处启动了SparkContext。然后，驱动程序在工作节点上的执行程序内运行操作。   SparkContext使用Py4J启动JVM并创建JavaSparkContext。默认情况下，PySpark将SparkContext作为’sc’提供，因此创建新的SparkContext将不起作用。      以下代码块包含PySpark类的详细信息以及SparkContext可以采用的参数。   class pyspark.SparkContext (    master = None,    appName = None,     sparkHome = None,     pyFiles = None,     environment = None,     batchSize = 0,     serializer = PickleSerializer(),     conf = None,     gateway = None,     jsc = None,     profiler_cls = &lt;class 'pyspark.profiler.BasicProfiler'&gt; )   以下是SparkContext的参数具体含义：      Master- 它是连接到的集群的URL。   appName- 您的工作名称。   sparkHome - Spark安装目录。   pyFiles - 要发送到集群并添加到PYTHONPATH的.zip或.py文件。   environment - 工作节点环境变量。   batchSize - 表示为单个Java对象的Python对象的数量。设置1以禁用批处理，设置0以根据对象大小自动选择批处理大小，或设置为-1以使用无限批处理大小。   serializer- RDD序列化器。   Conf - L {SparkConf}的一个对象，用于设置所有Spark属性。   gateway  - 使用现有网关和JVM，否则初始化新JVM。   JSC - JavaSparkContext实例。   profiler_cls - 用于进行性能分析的一类自定义Profiler（默认为pyspark.profiler.BasicProfiler）。 在上述参数中，主要使用master和appname。任何PySpark程序的会使用以下两行：   from pyspark import SparkContext sc = SparkContext(\"local\", \"First App\")   RDD   在介绍PySpark处理RDD操作之前，我们先了解下RDD的基本概念：      RDD代表Resilient Distributed Dataset，它们是在多个节点上运行和操作以在集群上进行并行处理的元素。RDD是不可变元素，这意味着一旦创建了RDD，就无法对其进行更改。RDD也具有容错能力，因此在发生任何故障时，它们会自动恢复。您可以对这些RDD应用多个操作来完成某项任务。    要对这些RDD进行操作，有两种方法 :      Transformation   Action   转换 - 这些操作应用于RDD以创建新的RDD。Filter，groupBy和map是转换的示例。   操作 - 这些是应用于RDD的操作，它指示Spark执行计算并将结果发送回驱动程序。   要在PySpark中应用任何操作，我们首先需要创建一个PySpark RDD。以下代码块具有PySpark RDD类的详细信息 :   class pyspark.RDD (    jrdd,     ctx,     jrdd_deserializer = AutoBatchedSerializer(PickleSerializer()) )   接下来让我们看看如何使用PySpark运行一些基本操作,用以下代码创建存储一组单词的RDD（spark使用parallelize方法创建RDD），我们现在将对单词进行一些操作。   PySpark SQL   PySpark的语法是从左到右串行的，便于阅读、理解和修正；SQL的语法是从内到外嵌套的，不方便维护；   PySpark继承Python优美、简洁的语法，同样的效果，代码行数可能只有SQL的十分之一；   Spark分转化操作和行动操作，只在行动操作时才真正计算，所以可以减少不必要的计算时间；   相对于SQL层层嵌套的一个整体，PySpark可以拆分成多步，并可以十分方便地把中间结果保存为变量，更有利于调试和修改；   PySpark可以与Python中的其他模块结合使用，可以将多种功能有机结合成一个系统   PySpark SQL模块许多函数、方法与SQL中关键字一样，可以以比较低的学习成本切换   最重要的，Spark是基于内存计算的，计算速度本身比Hive快很多倍   refer：https://www.jianshu.com/p/177cbcb1cb6f   ","categories": ["note"],
        "tags": [],
        "url": "http://localhost:4000/note/2019/08/14/PySpark%E5%88%9D%E5%AD%A6.html",
        "teaser":null},{
        "title": "领域建模 概念与数据建模",
        "excerpt":"   1、使用类图，分别对 Asg_RH 文档中 Make Reservation 用例以及 Payment 用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键            注意事项：                    对象必须是名词、特别是技术名词、报表、描述类的处理；           关联必须有多重性、部分有名称与导航方向           属性要注意计算字段                       数据建模，为了简化描述仅需要给出表清单，例如：                    Hotel（ID/Key，Name，LoctionID/Fkey，Address…..）                           邻域建模：         数据建模：            Hotel(name,star,addr,loc id,brief intro,favorite,price,rating,max-discount-off)       Room(type,date,isAvailable,reserved,price,reserved num,total num)       Reservation(check in date,check out date,number of nights)       traveler(name,email)       Payment (ID/PrimeryKey, ReservationID/ForeignKey, Date, Time, Total)       CreditCard (ID/PrimeryKey, TravelerID/ForeignKey, PaymentID/ForeignKey, Number, SecurityCode, ExpiryDate)           对payment用例开张领域建模         2、使用 UML State Model，对每个订单对象生命周期建模            建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。       建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。              ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/swsad/Domain-modeling/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/",
        "teaser":null},{
        "title": "用例建模 绘制用例图",
        "excerpt":"使用 UMLet 建模：           1、根据订旅馆建模文档，Asg-RH.pdf：              绘制用例图模型（到子用例）                         给出 make reservation 用例的活动图                       2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景                       分别用多泳道图建模三个场景的业务过程                      场景1                                         场景2                                         场景3                                           根据上述流程，给出快递柜系统最终的用例图模型             用正常色彩表示第一个业务流程反映的用例       用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor       用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor              ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/swsad/Use-case-modeling/%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1-%E7%BB%98%E5%88%B6%E7%94%A8%E4%BE%8B%E5%9B%BE/",
        "teaser":null},{
        "title": "软件项目过程模型与规划",
        "excerpt":"1、简单题           简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点              从项目特点、风险特征、人力资源利用角度思考           瀑布模型：              优点：定义了软件开发基本流程和活动；为项目提供了按阶段划分的检查点；当前一阶段完成后，只需要去关注后续阶段。它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。       缺点：各个阶段的划分固定；很难给出清晰的需求，对后期工作也造成阻碍；不同阶段所需要的知识技术不同，对人员要求不同，产生资源配置的问题。           增量模型：              优点：人员分配灵活；可以分批次提交软件产品，使用户及时的了解项目的进程；可以灵活的调节组件的开发顺序、优先级       缺点：要求待开发的软件系统可以被模块化；如果增量之间存在相交的情况且未能很好处理，则必须做全盘系统分析。           螺旋模型：             优点：设计上更加灵活，可以在项目的各个阶段进行变更；客户始终参与每个阶段的开发，保证了项目不偏离正确的方向以及项目的可控性；在每个迭代阶段植入软件测试，使每个阶段的质量得到保证。       缺点：迭代次数难以控制，可能超出预算或工期；周期过长导致软件技术发展与当前的差距，无法满足市场需求。           简述统一过程三大特点，与面向对象的方法有什么关系？            三大特点：                    用例驱动(use case driven)：从用户角度表达，既能被开发人员看懂也能被客户看懂           以体系结构为核心(architecture centric)：软件体系结构提供了所有其他发展演变的中心点，提供系统的”大局”，为发展提供组织框架           迭代及增量(iterative and evolutionary)：迭代和增量方法允许开发以不完整、不完美的知识开始，并且迭代和增量会逐步趋向稳定，能有效的管理需求变化。                           简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？            划分准则是在每个阶段的结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段。       四大阶段：                    初始阶段：生命周期目标(Lifecycle Objective)里程碑，评价项目基本的生存能力。           细化阶段：生命周期结构(LifecycleArchitecture)里程碑，为系统的结构建立了管理基准并使项目小组能够在构建阶段中进行衡量。此刻，要检验详细的系统目标和范围、结构的选择以及主要风险的解决方案。           构造阶段：初始功能(Initial Operational)里程碑，决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运作。           交付阶段：产品发布(Product Release)里程碑，确定目标是否实现，是否应该开始另一个开发周期。                           软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？            因为根据统一过程模型，各个阶段的生命周期是固定的，在软件开发的过程中有健胃明确的时间限制。这种生命周期方法为发布软件产品提供了依据。因此，软件企业能够按照固定的节奏生产、固定周期发布软件产品。       它可以让企业更加高效的把控软件开发的进度和预算，更加灵活的调配人力物力资源，提高效益           ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/swsad/modeling-and-planning/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%A7%84%E5%88%92/",
        "teaser":null},{
        "title": "软件的本质与软件工程科学",
        "excerpt":"1.软件工程的定义   Software engineering is:      the application of a systematic, disciplined, quantifiable approach to the develpment, operation, and maintenace of software, that is, the application of engineering to software   the study of approaches in (1)1   2. 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法   本质原因：   The software crisis was due to the rapid increases in computer power and the complexity of the problems that could not be tackled. With the increase in the complexity of the software, many software problems arose because existing methods were in sufficient.   表现：      Project running over-budget   Project running over-time   Software was very inefficient   Software was of low quality   Softwaree often did not meet requirements   Projects were unmanageable and code difficult to maintain   Software was never delivered   2   克服方法:   Build the methods and knowledge system of software preduciton, systematic and up-to-date software engineering methods are also needed to avoid software crisis.   3. 软件生命周期   A software development life cycle is the process of dividing software development work into disinct phases to improve design, product management, and project management. Most modern develpment processes ca be vaguely described as agile. Other methodologies include waterfall, prototyping, iterative and incremental development, spiral development, rapid application development, and extreme programming.   4. SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）   v3      Software Requirements：软件需求。软件需求涉及到引出、协商、分析、规范和验证，软件需求表达了对软件产品的需求和约束，这些需求和约束有助于解决一些实际问题。   Software Design：软件设计。软件设计被定义位系统或组件的体系结构、组件、接口和其他特征的过程，以及改过程的结果。软件设计过程是软件工程生命周期活动，在该活动中，软件需求被分析，以产生对软件内部结构及其行为的描述，这些描述将作为软件构建的基础。   Software Construction：软件构建。软件构建是知通过详细设计、编码、单元测试、集成测试、调试和验证相结合，对工作软件进行详细创建。   Software Testing：软件测试。测试是对产品质量进行评估并通过识别缺陷来改进产品质量的活动。软件测试涉及到在一组有限的测试用例上根据预期行为动态地验证程序的行为。这些测试用例是从(通常非常大的)执行域中选择的。   Software Maintenance：软件维护。软件维护包括增强现有的功能，使软件适应新的和修改的操作环境，以及纠正缺陷。这些类别被称为完善的、自适应的和纠正的软件维护。   Software Configuration Management：软件配置管理。系统的配置是硬件、固件、软件或它们的组合的功能和/或物理特征。它还可以看作是硬件、固件或软件项目的特定版本的集合，这些版本根据特定的构建过程组合在一起，以服务于特定的目的。因此，软件配置管理(SCM)是在不同的时间点识别系统配置的规程，以便系统地控制配置的更改，并在整个软件生命周期中维护配置的完整性和可追溯性。   Software Engineering Management：软件工程管理。软件工程管理包括计划、协调、测量、报告和控制一个项目或程序，以确保软件的开发和维护是系统的、有纪律的和量化的。   Software Engineering Process：软件工程过程。涉及软件生命周期过程的定义、实现、评估、度量、管理和改进。所涵盖的主题包括过程实现和变更(过程基础结构、过程实现和变更的模型以及软件过程管理);过程定义(软件生命周期模型和过程，过程定义、过程适应和过程自动化的符号);过程评估模型和方法;测量(过程测量、产品测量、测量技术、测量结果质量);以及软件过程工具。   Software Engineering Models and Methods：软件工程模型和方法。软件工程模型和方法解决了包含多个生命周期阶段的方法。所涵盖的主题包括建模(软件工程模型的原理和属性;语法、语义、不变量;(前置条件、后置条件和不变量);模型的类型(信息、结构和行为模型);分析(对正确性、完整性、一致性、质量和交互进行分析;可追溯性;和权衡分析);以及软件开发方法(启发式方法、正式方法、原型方法和敏捷方法)。   Software Quality：软件质量。软件质量是一个普遍存在的软件生命周期问题，包括软件质量的基础(软件工程文化、软件质量特征、软件质量的价值和成本、软件质量改进);软件质量管理过程(软件质量保证、验证和验证、评审和审计);以及实际的考虑(缺陷特性、软件质量度量和软件质量工具)。   Software Engineering Professional Practice：软件工程专业实践。软件工程专业实践是指软件工程师必须具备的知识、技能和态度，以一种专业、负责和道德的方式来实践软件工程。它涵盖专业(专业行为、专业协会、软件工程标准、雇佣合同、法律问题)、伦理准则、团队动态(在团队中工作，认知问题的复杂性，与利益相关者的互动，处理不确定性和模糊性，处理多元文化环境)和沟通能力。   Software Engineering Economics：软件工程经济学。软件工程经济学关注于在业务上下文中做出决策，以使技术决策与组织的业务目标保持一致。所涵盖的主题包括软件工程经济学的基本原理(建议、现金流量、金钱的时间价值、规划期限、通货膨胀、折旧、重置和退休决定);非营利性决策(成本效益分析、优化分析);评估、经济风险和不确定性(评估技术、风险和不确定性下的决策);以及多属性决策(值和度量尺度、补偿和非补偿技术)。   Computing Foundations：计算基础。计算基础涵盖了为软件工程实践提供必要的计算背景的基本主题。主题包括问题解决技术、抽象、算法和复杂性、编程基础、并行和分布式计算的基础、计算机组织、操作系统和网络通信。   Mathematical Foundations：数学基础。数学基础涵盖了为软件工程实践提供必要数学背景的基本主题。主题包括集合、关系和函数;基本命题逻辑和谓词逻辑;证明技术;图表和树木;离散型概率;语法和有限状态机;和数论。   Engineering Foundations：工程基础。工程基础涵盖了为软件工程实践提供必要的工程背景的基本主题。所涵盖的主题包括实证方法和实验技术;统计分析;测量和度量;工程设计;仿真和建模;以及根本原因分析。   5. 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。      Level 1 - Initial 企业对项目的目标与要做的努力很清晰，项目的目标得以实现。但是由于任务的完成带有很大的偶然性，企业无法保证在实施同类项目的时候仍然能够完成任务。企业在一级上的项目实施对实施人员有很大的依赖性。   Level 2 - Managed 企业在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对相关的项目实施人员有相应的培训，对整个流程有监测与控制，并与上级单位对项目与流程进行审查。   Level 3 - Deined 企业不仅能够对项目的实施有一整套的管理措施，并保障项目的完成；而且，企业能够根据自身的特殊情况以及自己的标准流程，将这套管理体系与流程予以制度化这样，企业不仅能够在同类的项目上生到成功的实施，在不同类的项目上一样能够得到成功的实施。科学的管理成为企业的一种文化，企业的组织财富。   Level 4 - Quantiatively Managed 在量化管理级水平上，企业的项目管理不仅形成了一种制度，而且要实现数字化的管理。对管理流程要做到量化与数字化。通过量化技术来实现流程的稳定性，实现管理的精度，降低项目实施在质量上的波动。   Level 5 - Optimizing 在优化级水平上，企业的项目管理达到了最高的境界。企业不仅能够通过信息手段与数字化手段来实现对项目的管理，而且能够充分利用信息资料，对企业在项目实施的过程中可能出现的次品予以预防。能够主动地改善流程，运用新技术，实现流程的优化。   6. 用自己语言简述 SWEBok 或 CMMI （约200字）   能力成熟度模型集成(Capability Maturity Model Integration, CMMI)是CMM模型的最新版本，是应用于软件业项目的管理方法，SEI在部分国家和地区开始推广和试用。CMMI用阶段式的表现方法将过程区域分成了5个成熟度级别，帮助实施CMMI的组织建议一条比较容易实现的过程改进发展道路。CMMI为改进一个组织的各种过程提供了一个单一的集成化框架，新的集成模型框架消除了各个模型的不一致性，减少了模型间的重复，增加透明度和理解，建立了一个自动的、可扩展的框架。因而能够从总体上改进组织的质量和效率。CMMI主要关注点就是成本效益、明确重点、过程集中和灵活性四个方面。                  Software engineering &#8617;                  Software crisis &#8617;           ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/swsad/software-engineering-science/%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%A7%91%E5%AD%A6/",
        "teaser":null},{
        "title": "软件项目与知识团队管理",
        "excerpt":"1、简答题      用简短的语言给出对分析、设计的理解。            分析：在研究程序或需求的过程中，把事务、概念分解成较简单的组成部分，分别加以考察，找出各自的本质属性和彼此间的联系       设计：指预先描绘出工作结果的样式、结构及形貌。           用一句话描述面向对象的分析与设计的优势。            面向对象的分析利用面向对象的信息建模概念，将对象作为程序的基本单元，将程序和数据封装其中，提高软件的重用性、灵活性和扩展性           简述 UML（统一建模语言）的作用。考试考哪些图？            UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。       Structure diagrams（结构图）、Behavior diagrams（行为图）、Interaction diagrams（交互图）           从软件本质的角度，解释软件范围（需求）控制的可行性            虽然软件本身的复杂性、不可见性、不一致性、可变性，在软件开发的过程，软件开发者围绕客户目标，发现并满足客户感兴趣的内用例建模-用例编写容，实现软件最具创造价值的功能，因此软件范围控制是可行的。           2、项目管理实践           看板使用练习（提交看板执行结果贴图，建议使用 Git project）              使用截图工具（png格式输出），展现你团队的任务 Kanban       每个人的任务是明确的。必须一周后可以看到具体结果       每个人的任务是1-2项       至少包含一个团队活动任务                       UML绘图工具练习（提交贴图，必须使用 UMLet）              请在 参考书2 或 教材 中选择一个类图（给出参考书页码图号）              From 《UML和模式应用》P193 图16-16   ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/swsad/team-management/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/",
        "teaser":null},{
        "title": "用例建模-绘制用例图",
        "excerpt":"1、简答题           用例的概念       用例（Use Case）：是一种通过用户的使用场景来获取需求的技术。一个用例定义了外部执行者和被考虑的系统之间的交互来实现一个业务目标，用例描述了满足业务目标的业务活动，没有涉及特定的实现寓言并且要求合适的细节级别。            用例和场景的关系？什么是主场景或 happy path？       每个用例提供一个或多个场景，该场景说明了系统是如何和最终用户或其他系统互动，也就是谁可以用系统做什么。 参与者在用例中所遵循的主逻辑路径，描述了各项工作都正常进行时用例的工作方式，所以通常称为主场景或happy path            用例有哪些形式？                       Brief：           提供一段通过关于主要的happy path总结。可以快速构建，在需求的早期提供主题和范围的快速了解。                        Casual：           非正式的段落格式，包含多种场景的多个段落，比brief use case相比具有更多的细节，但无法被用作正式的用例文本。                        Fully：           所有的步骤和变化都详细的写出，并且有支持部分，例如先决条件和成功保证。                        对于复杂业务，为什么编制完整用例非常难？       因为复杂的业务涉及到的场景非常多，并且各个场景之间也有彼此的关联，因此这给编制一个完整的用例带来了很大的困难，业务人员不仅要熟悉各种业务场景的流程，分析构建一个场景的细节也至关重要。            什么是用例图？       是用户与系统交互的最简表示形式，展现了用户和与他相关的用例之间的关系。通过用例图，人们可以获知系统不同种类的用户和用例。            用例图的基本符号与元素？              参与者(Actor),表示的是一个系统用户，也就是与应用程序进行交互的用户、组织或者外部系统。       用例(Use Case)：表示的是对系统提供功能、服务的一种描述。       用例关系：                    包含关系(include)：表示用例可以简单地包含其他用例所具有的行为           泛化关系(Generalization)：值一个父用例可以被特化形成多个子用例           关联关系(Association)：表示的是参与者与用例之间的关系           扩展/延伸关系(Extend)：表示在一定条件下，把新的行为加入到已有的用例中，获得的新用例叫做扩展用例。                                用例图的画法与步骤              确定研讨的系统、系统的参与者；哪些人会使用这个系统、系统需要从哪些人或其他系统中获得数据….       确定用例，根据参与者来确定系统的用例，主要是看各参与者需要系统提供什么样的服务，或者说参与者是如何使用系统的。       描述用例规约，描述每一个有例的详细信息，这些信息包含在用例规约中，用例模型是由用例图和每一个用例的详细描述――用例规约所组成的。       检查用例模型，用例模型完成之后，可以对用例模型进行检查，看看是否有遗漏或错误之处。                用例图给利益相关人与开发者的价值有哪些？              对于利益相关人：                    可以直观的反应系统的功能结构，保证系统按照需求进行设计           用例通常使用结构化模板编写，辅以可视化UML图标，促进利益相关人与开发者进行的沟通，根据需求的复杂程度对程序进行细节上的增减调节，及时响应用户。                       对于开发者：                    用例图为开发者提供了一个清晰的开发蓝图，提高系统的开发效率和质量           用例图可以指导开发和测试，在整个过程中对工作流起指导作用                           2、建模练习题（用例模型）      选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：            请使用用户的视角，描述用户目标或系统提供的服务       粒度达到子用例级别，并用 include 和 exclude 关联它们       请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例       尽可能识别外部系统和服务                   携程：                   订电影票：                      然后，回答下列问题：                       为什么相似系统的用例图是相似的？           因为相似的系统，面对的参与者和用例是相似的，用例之间的关系也是同构的。用户预期的功能也是接近的。即使不同的同类系统具有不一样的拓展功能，在用例图上所体现的结构框架也是相似的。                        如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术           在用例图上添加创新业务，满足不同时代、不同地区用户的不同需求，突出创新和与时俱进；替换老旧功能，淘汰落后、不受欢迎的业务。                        如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用           通过创新点在图中的位置来判断。如果创新位于较高的父级，则作用比较大。如果是子类或者是被包括的关系，则作用相对较小。                        请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表                                                  ID               Name               Imp               Est               Itern               How to demo                                                               1               find hotel               10               16               4               find the thoel by location, data, name or type                                         2               make reservation               7               12               6               determine the room type , time of the hotel                                         3               manage basket               5               8               1               confirm or cancel                                         4               payment               5               8               4               make payment using outside paying system                                                        根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算                                  用例       #事务       #计算       原因       UC权重                       find hotel       7       6       框架       平均                 make reservation       5       4               简单                 manage basket       1       1               简单                 payment       4       2               简单           ","categories": ["jekyll","update"],
        "tags": [],
        "url": "http://localhost:4000/swsad/use-case-writing/%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1-%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99/",
        "teaser":null}]
